##  phlexicon.py
##
##  Author: Geoff Bacon <bacon@berkeley.edu>. 
##
##  For license information, see LICENSE.TXT

"""
FLEx lexicon reader.

This module provides functions for reading, writing and manipulating 
FLEx lexicons.

Classes
-------

A single class is defined: Lexicon.

Working with LIFT files
-----------------------

================    ===============================
Method              Description
================    ===============================
summary             Print summary of lexicon.
getEntry            Return entry in lexicon.
getDateCreated      Return date created of entry.
getDateModified     Return date modified of entry.
getHeadword         Return headword of entry.
getPOS              Return all POSs of entry.
getGloss            Return all glosses of entry.
setHeadword         Set headword of entry.
setPOS              Set POS of entry.
addField            Add field to entry.
addCVField          Add CV pattern field to entry.
pprint              Pretty print an entry.
check               Check for missing data.
write               Write to file.
================    =============================

Example usage
-------------

python3 phlexicon.py

Read in a LIFT file:

>>> tsw = Lexicon("data/tswefap.lift")

Get all the verbs in the lexicon NB: entries are indexed by guid.

>>> verbs = [guid for guid in tsw.lexemes if "verb" in tsw.getPOS(guid)] 

Inspect a particular entry:

>>> tsw.pprint('3bceeed7-1f99-424d-9690-3d6d54d85497')
Headword: sō
POS: ['verb']
Gloss: ['wash']

Get all the words in the lexicon that start with a "w":

>>> w_words = [guid for guid in tsw.lexemes 
               if tsw.getHeadword(guid).startswith("w")]

Get all the words in the lexicon that have been modified 
since 5th December 2015:

modified = [guid for guid in tsw.lexemes
            if tsw.getDateModified(guid) > '2015-12-05T20:53:32Z']

Get all the words that have to do with washing:

wash_words = [guid for guid in tsw.lexemes if "wash" in tsw.getGloss(guid)]

Enter negative data:

>>> tsw.addField('3bceeed7-1f99-424d-9690-3d6d54d85497',
                 "negative-example", "wuub so kwa")
                 
Access negative data:
                 
>>> for element in tsw.root.iter():
...    if element.get("type") == "negative-example":
...            print(element.findtext("form/text")
...
wuub so kwa

Global spelling change of only Tswefap data:

>>> pattern = re.compile("g")
>>> for element in tsw.root.iter():
...     if element.get("lang") == "nnz":
...         if pattern.search(element.findtext("text")):
...             pattern.sub("k", element.find("text").text)

Search for a specific tone pattern in headwords:

>>> headwords = [tsw.getHeadword(guid) for guid in tsw.lexemes]
>>> tone_dict = {}
>>> for headword in headwords:
...     tones = []
...     for ch in headword:
...         if "ACUTE" in uc.name(ch):
...            tones.append("H")
...         if "GRAVE" in uc.name(ch):
...            tones.append("L")
...     tone_dict[headword] = tones
...
>>> HL = [key for key in tone_dict if tone_dict[key] == ["H", "L"]]

"""
__all__ = ['Lexicon']

import re
import sys

from datetime import datetime
from collections import Counter

from util import *
    
# === Public class ===

class Lexicon(AbstractFlexObject):
    """
    Class for reading and processing FLEx's LIFT files.
    
    self.lexemes holds a list of the globally unique identifiers (guid) 
    generated by FLEx. All methods defined below refer to entries 
    by their guid.
    """
    
    # === Private utilities ===
    
    def __init__(self, filename):
        AbstractFlexObject.__init__(self, filename)
        self.lexemes = []
        entries = self.root.findall('entry')
        for entry in entries:
            guid = entry.get('guid')
            self.lexemes.append(guid)
        self.summary()
        
    def _getField(self, guid, field):
        entry = self.getEntry(guid)
        return entry.get(field)
    
    def _getSenses(self, guid):
        entry = self.getEntry(guid)
        return entry.findall("sense")
    
    def _setDateModified(self, guid):
        entry = self.getEntry(guid)
        date = datetime.utcnow().isoformat().split(".")[0] + "Z"
        entry.set("dateModified", date)
        
    #TODO deal with tones, diacritics, etc.    
    def _cv(self, guid):
        """
        Returns CV structure of an entry.
        """
        headword = self.getHeadword(guid)
        s = headword.lower()
        s = re.sub(r'[^a-z]',     r'_', s)
        s = re.sub(r'[aeiou]',    r'V', s)
        s = re.sub(r'[^V_]',      r'C', s)
        return (s)
        
    # TODO Implement pretty print of XML
    def _printEntry(self, guid):
        """
        Print raw XML of an entry.
        """
        entry = self.getEntry(guid)
        tree = et.ElementTree(entry)
        tree.write(sys.stdout, encoding="unicode")
        
    def _checker(self, guid):
        """
        Return true if an entry is missing a value.
        """
        all_info = self._all(guid)
        for field in all_info:
            if _isEmpty(all_info[field]):
                return True # Means value is missing
        return False

    def _all(self, guid):
        """
        Return a dictionary of all the information in an entry.
        """
        # TODO As I think of more fields to check, enter them here.
        entry = self.getEntry(guid)
        headword = self.getHeadword(guid)
        pos = self.getPOS(guid)
        gloss = self.getGloss(guid)
        all_info = {'headword': headword, 'pos': pos, 'gloss': gloss}
        return all_info  
    
    # === Public methods ===
     
    # TODO Figure out more basic facts to print     
    def summary(self):
        self.summaryHeading()
        num_of_entries = len(self.lexemes)
        num_of_missing = len(self.check())
        print("Number of entries:", num_of_entries, "\n")
        print("Number of entries with missing values:", num_of_missing, "\n")
        
    def getEntry(self, guid):
        """
        Find an entry in the lexicon by its guid.
        """
        entry = self.root.find("entry[@guid='{}']".format(guid))
        return entry
              
    def getDateModified(self, guid):
        return self._getField(guid, 'dateModified') 
    
    def getDateCreated(self, guid):
        return self._getField(guid, 'dateCreated')
    
    def getHeadword(self, guid):
        entry = self.getEntry(guid)
        return entry.findtext("lexical-unit/form/text")
        
    def getPOS(self, guid):
        senses = self._getSenses(guid)
        pos = []
        for sense in senses:
            grammatical_info = sense.find("grammatical-info")
            category = grammatical_info.get('value')
            pos.append(category)
        return pos
    
    def getGloss(self, guid):
        senses = self._getSenses(guid)
        glosses = []
        for sense in senses:
            gl = sense.findtext("gloss/text")
            glosses.append(gl)
        return glosses
        
    def setHeadword(self, guid, headword):
        entry = self.getEntry(guid)
        entry.find("lexical-unit/form/text").text = headword
        self._setDateModified(guid)
        
    def setPOS(self, guid, fromPOS, toPOS):
        senses = self._getSenses(guid)
        for sense in senses:
            if sense.find("grammatical-info").get('value') == fromPOS:
                sense.find("grammatical-info").set('value', toPOS)
        self._setDateModified(guid)

    def addField(self, guid, field_name, field_value):
        """
        Add a new field to an entry.
        """
        entry = self.getEntry(guid)
        newfield = et.SubElement(entry, "field", attrib={'type':field_name})
        newform = et.SubElement(newfield, "form", attrib={'lang':'en'})
        newtext = et.SubElement(newform, "text")
        newtext.text = field_value
        self._setDateModified(guid)
        
    def addCVField(self, guid):
        self.addField(guid, 'cv-pattern2', self._cv(guid))
            
    def pprint(self, guid):
        """
        Print info for an entry in human-readable form.
        """
        all_info = self._all(guid)
        for key in all_info:
            if isinstance(all_info[key], str):
                print(key, ":", all_info[key])
            elif isinstance(all_info[key], list):
                print(key, ":", "; ".join(all_info[key]))
        print("*"*20)
            
    def check(self):
        """
        Return list of guids that have missing values.
        """
        missing = []
        for guid in self.lexemes:
            if self._checker(guid):
                missing.append(guid)
        return missing
  
def demo():
    pass

# if __name__ == '__main__':
#     import os
#     base, ext = os.path.splitext(sys.argv[1])
#     if ext == ".lift":
#         lexicon = Lexicon(sys.argv[1])    
#         print("Your lexicon is ready as 'lexicon'.")
#         demo()
#     else:
#         print("That's not a LIFT file!")


#     Report duplicates
#
#     def _findSameHeadword(self):
#         """
#         Returns a list of entries with the same headword.
#         """
#         lexicon = [(guid, self.getHeadword(guid)) for guid in self.lexemes]
#         headwords = [headword for guid, headword in lexicon]
#         same_headword = [guid for (guid, headword) in lexicon if Counter(headwords)[headword] > 1]
#         return same_headword
#         
#     def _findSameGloss(self):
#         """
#         Returns a list of entries with the same gloss.
#         """
#         lexicon = [(guid, self.getPOS(guid)) for guid in self.lexemes]
#         categories = [pos for guid, pos in lexicon]
#         same_pos = [guid for (guid, pos) in lexicon if Counter(categories)[pos] > 1]
#         return same_pos
#             
#     def _findSameField(self, field):
#         """
#         Returns a list of entries with the same value in Field.
#         """
#         if field == "headword":
#             function = self.getHeadword
#         if field == "pos":
#             function = self.getPOS
#         if field == "gloss":
#             function = self.getGloss
#             
#         lexicon = [(guid, function(guid)) for guid in self.lexemes]
#         values = [value for guid, value in lexicon]
#         same = [guid for (guid, thing) in lexicon if Counter(values)[thing] > 1]
#         return same